# API

Для простоты пока будет 2 игрока на игру, хотя их может быть любое количество. Предполагается, что роботы будут общаться
друг с другом посредством периодического опроса сервера, исходники которого, собственно, здесь и лежат.  Имеются
следующие типы запросов.

- Запрос на создание игры.
- Запрос списка игр, ожидающих второго игрока.
- Запрос на присоединение к игре.
- Опрос состояния по текущей игре.
- Запрос с ходом.

Идентификатор игрока передаётся в HTTP-заголовке FD-PLAYER-ID.

## Запрос на создание игры

POST */create*

В случае успеха возвращается JSON с хешем игры. Данная игра становится доступной в списке ожидающих игр.

```json
{
  "status": "ok",
  "hash": "ifmo6z63"
}
```

## Запрос списка игр, ожидающих второго игрока

GET */pending*

В ответ возвращается массив с хешами ожидающих игр и некий контент-хеш, который не меняется, если не изменился список
ожидающих игр (т.е. его можно использовать для того, чтобы предотвратить повторную перерисовку списка, например).

```json
{
  "status": "ok",
  "games": [
    {"hash": "ifmo6z63"},
    {"hash": "ifmzu9i6"},
    {"hash": "ifn099jx"}
  ],
  "content_hash": "7bfaf4ec"
}
```

## Запрос на присоединение к ожидающей игре

POST */join/{hash}*

В случае успеха возвращается:

```json
{
  "status": "ok"
}
```

В случае ошибки:

```json
{
  "status": "error",
  "message": "error message"
}
```

## Опрос состояния по текущей игре

GET */state/{hash}*

Возвращается JSON с текущим состоянием игры. Указан игрок, совершающий ход, число сделанных бросков кубиков, комбинация,
выпавшая на кубиках, таблица с результатами предыдущих бросков.

```json
{
  "status": "ok",
  "state": "active",
  "step_player": 23,
  "count_rolling": 1,
  "dices": [2, 1, 1, 6, 4],
  "table": {
    "pair": 27,
    "two_pairs": null,
    "triplet": 12,
    "full_house": null,
    "straight": 20,
    "big_straight": null,
    "odd": null,
    "even": null,
    "quads": 21,
    "poker": null,
    "sum": null
  }
}
```

## Запрос с ходом

POST */state/{hash}*
